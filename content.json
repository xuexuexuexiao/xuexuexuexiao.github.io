{"meta":{"title":"volsnow","subtitle":"胡说","description":"仅个人胡说","author":"volsnow","url":"https://xuexuexuexiao.github.io","root":"/"},"pages":[],"posts":[{"title":"redis概述","slug":"redis概述","date":"2021-07-29T08:04:18.000Z","updated":"2021-07-29T08:11:44.116Z","comments":true,"path":"uncategorized/redis概述/","link":"","permalink":"https://xuexuexuexiao.github.io/uncategorized/redis%E6%A6%82%E8%BF%B0/","excerpt":"Redis 的安装 启动下载docker pull redis 检查镜像 docker images","text":"Redis 的安装 启动下载docker pull redis 检查镜像 docker images 启动(重要)创建实例并启动 12345678910mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.conf docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf或者docker run -p 6379:6379 -v $PWD/data:/data -d redis:3.2 redis-server --appendonly yes（表示添加aof） -p 映射端口 –name 启动的名称 -v 映射文件夹（重点看） -v 挂载目录，规则与端口映射相同。 ​ 为什么需要挂载目录：个人认为docker是个沙箱隔离级别的容器，这个是它的特点及安全机制，不能随便访问外部（主机）资源目录，所以需要这个挂载目录机制。 例如，上面的-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf 就是表示 把我本地的目录/mydata/redis/conf下的config映射到容器Redis中/etc/redis目录下 再例如：（后面会讲到Redis的持久化机制）在Redis持久化机制中，有一种是通过rdb来进行持久化的。当我执行命令save时， 就会触发快照的rdb机制来进行持久化，同时会在我的/mydata/redis/data目录下生成 dump.rdb 文件，如下 然后，如果我需要docker Redis容器通过dump.rdb文件进行数据迁移或恢复数据，就需要把我本地的dump.rdb映射到 容器中的Redis中：（里面的目录可以自己修改） docker run -it –name aley_redis -v /home/aley/data/dump.rdb:/data/dump.rdb -p 6379:6379 redis:latest /bin/bash 如果不知道生成的dump.rdb文件保存在什么位置可以通过 docker inspect 容器名（容器ID） 查看容器信息在MOUNTS 下的Source的值可以看到保存位置 -d redis 表示后台启动redis redis-server /etc/redis/redis.conf 以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/redis/redis.conf 配置检查运行的容器 1docker ps 进入redis容器，连接redis客户端 123docker exec -it redis(Redis在容器中的ID) redis-cliset aa bget aa //输出==&gt;b 目前没有配置过redis持久化，重启redis缓存会消失，所以需要配置redis持久化 12vi /mydata/redis/conf/redis.conf // 输入appendonly yes 并保存docker restart redis // 重启redis容器 直接拉取的Redis镜像没有配置文件，需要自己下载配置文件，配置文件下载地址：http://download.redis.io/redis-stable/redis.conf 。将修改后的配置文件挂载到容器里。然后启动Redis服务时指定配置文件即可（命令 wget http://download.redis.io/redis-stable/redis.conf ） 以上的部分内容参考： docker Redis容器通过dump.rdb文件进行数据迁移或恢复数据 docker安装redis后如何查看日志_Docker如何安装redis docker 安装redis并配置redis.conf 什么是RedisRedis 开源 遵循BSD 基于内存数据存储 被用于作为 数据库 缓存 消息中间件 总结: redis是一个内存型的数据库 Redis特点 Redis是一个高性能key/value内存型数据库 Redis支持丰富的数据类型 Redis支持持久化 Redis单线程,单进程 Redis操作指令持久化机制client redis[内存] —–&gt; 内存数据- 数据持久化–&gt;磁盘 什么是Redis的持久化 持久化:就是将数据永久保存到磁盘的过程 称之为数据持久化 Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是: 快照(Snapshot) 也通常称之为rdb AOF (Append Only File) 只追加日志文件 快照持久化1. 特点这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是redis的默认开启持久化方式,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。 那么什么时候触发去生成快照呢，就是说，我们在操作数据库的时候，这个快照是什么时候生成的呢，从而去保证数据的持久化呢。那么下面就要讨论快照的生成时机 2. 快照的生成时机快照的生成时机有两个 手动快照（客户端的方式） bgsave :bgsave保证快照持久化同时不会阻塞redis主服务提供服务 客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。 ​ 1名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务 主进程继续着处理客户端的命令请求 子进程生成快照到磁盘中 save：接收到save命令的redis服务会在快照创建完毕之前阻塞所有客户端 客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令 注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务 shutdown：redis接收到这个指令会自动执行save命令，在save创建快照结束后关闭redis服务 例如，你看，当我执行save命令时，就出生成一个dump.rdb的文件 就会触发快照的rdb机制来进行持久化，同时会在我的/mydata/redis/data目录下生成 dump.rdb 文件，如下 自动快照（服务器配置自动触发） 根据redis.conf 中配置save选项自动触发BGBAVE指令 ​ save seconds(时间:单位秒) changes (改变: redis中key改变) 例如 save 900 1 save 300 1 save 60 1000 3. 配置生成快照名称和位置12345#1.修改生成快照名称- dbfilename dump.rdb# 2.修改生成位置- dir ./ AOF只追加日志文件1. 特点这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集. 我们可以先load一眼，aof里面记载的是啥，有一个初步的整体印象 那么如何开启这个持久化 2. 开启AOF持久化在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启 123# 1.开启AOF持久化 - a.修改 appendonly yes 开启持久化 - b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称 3. 日志追加频率对于我们上面说的rdb快照方式，配置 save 1000 1 这种命令在配置文件中，表示当至少有一个key变化时，每隔1000S后就生成一个快照 同样，对于日志追加的方式，也有它追加的频率 1234567891011121314# 1.always 【谨慎使用】- 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度- 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢- 失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;- 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;- 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。# 2.everysec 【推荐】- 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘- 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。# 3.no 【不推荐】- 说明: 由操作系统决定何时同步 - 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。 1. 修改同步频率12# 1.修改日志同步频率 在redis.conf中修改- 修改appendfsync everysec|always|no 指定 AOF文件的重写1. AOF带来的问题AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。 2. AOF重写用来在一定程度上减小AOF文件的体积 注意：重写实际上就是一种替换，就是将原来的文件覆盖的方式来重写 3. 触发重写的方式12345678# 1.客户端方式触发重写- 执行BGREWRITEAOF命令 不会阻塞redis的服务# 2.服务器配置方式自动触发- 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓- 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久- 化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,- 会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大 4. 重写原理注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。 1234567# 重写流程- 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令- 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就- 能保证如果子进程重写失败的话并不会出问题。- 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的- 写命令也写入到临时文件。- 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。 持久化总结两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。 无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。 Redis 主从复制主从复制主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据 无法解决: 1.master节点出现故障的自动故障转移 主从复制架构图 搭建主从复制1234567891011121314# 1.准备3台机器并修改配置- master port 6379 bind 0.0.0.0 - slave1 port 6380 bind 0.0.0.0 slaveof masterip masterport- slave2 port 6381 bind 0.0.0.0 slaveof masterip masterport 12345# 2.启动3台机器进行测试- cd /usr/redis/bin- ./redis-server /root/master/redis.conf- ./redis-server /root/slave1/redis.conf- ./redis-server /root/slave2/redis.conf Redis 的哨兵机制Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有自动故障转移功能的主从架构。 无法解决: 1.单节点并发压力问题 2.单节点内存和磁盘物理上限 哨兵架构原理 搭建哨兵架构123456789# 1.在主节点上创建哨兵配置- 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；# 2.配置哨兵，在sentinel.conf文件中填入内容：- sentinel monitor 被监控数据库名字（自己起名字） ip port 1# 3.启动哨兵模式进行测试- redis-sentinel /root/sentinel/sentinel.conf 说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。 通过SpringBoot操作哨兵12345# redis sentinel 配置# master书写是使用哨兵监听的那个名称spring.redis.sentinel.master=mymaster# 连接的不再是一个具体redis主机,书写的是多个哨兵节点spring.redis.sentinel.nodes=192.168.202.206:26379 注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) 解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限 Redis 集群redis集群 cluste rredis集群解决问题: 1.数据冗余备份2.自动故障转移核心 解决:单节点的并发压力和物理上限 集群细节1234- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.- 节点的fail是通过集群中超过半数的节点检测失效时才生效. - 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可- redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://xuexuexuexiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"redis整合SpringBoot","slug":"redis整合SpringBoot","date":"2021-07-29T07:50:10.000Z","updated":"2021-07-29T07:52:47.498Z","comments":true,"path":"uncategorized/redis整合SpringBoot/","link":"","permalink":"https://xuexuexuexiao.github.io/uncategorized/redis%E6%95%B4%E5%90%88SpringBoot/","excerpt":"Spring 框架为我们在持久层提供了很多的支持,也就是提供了Spring Data","text":"Spring 框架为我们在持久层提供了很多的支持,也就是提供了Spring Data 我们只需要通过简单的导入依赖，既可以完成Spring对数据层的操作 Spring Boot Data(数据) Redis 中提供了RedisTemplate和StringRedisTemplate，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。 注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口 环境准备1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置application.propertie123spring.redis.host=localhostspring.redis.port=6379spring.redis.database=0 使用StringRedisTemplate和RedisTemplate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@Autowired private StringRedisTemplate stringRedisTemplate; //对字符串支持比较友好,不能存储对象 @Autowired private RedisTemplate redisTemplate; //存储对象 @Test public void testRedisTemplate()&#123; System.out.println(redisTemplate); //设置redistemplate值使用对象序列化策略 redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());//指定值使用对象序列化 //redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date())); User user = (User) redisTemplate.opsForValue().get(&quot;user&quot;); System.out.println(user);// Set keys = redisTemplate.keys(&quot;*&quot;);// keys.forEach(key -&gt; System.out.println(key)); /*Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(name);*/ //Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;); //System.out.println(xiaohei); /*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;); Object name = redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(name);*/ /*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;); List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1); lists.forEach(list-&gt; System.out.println(list));*/ &#125; //key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key //boundValueOps 用来对String值绑定key //boundListOps 用来对List值绑定key //boundSetOps 用来对Set值绑定key //boundZsetOps 用来对Zset值绑定key //boundHashOps 用来对Hash值绑定key @Test public void testBoundKey()&#123; BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(&quot;name&quot;); nameValueOperations.set(&quot;1&quot;); //yuew nameValueOperations.set(&quot;2&quot;); String s = nameValueOperations.get(); System.out.println(s); &#125; //hash相关操作 opsForHash @Test public void testHash()&#123; stringRedisTemplate.opsForHash().put(&quot;maps&quot;,&quot;name&quot;,&quot;小黑&quot;); Object o = stringRedisTemplate.opsForHash().get(&quot;maps&quot;, &quot;name&quot;); System.out.println(o); &#125; //zset相关操作 opsForZSet @Test public void testZSet()&#123; stringRedisTemplate.opsForZSet().add(&quot;zsets&quot;,&quot;小黑&quot;,10); Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(&quot;zsets&quot;, 0, -1); zsets.forEach(value-&gt; System.out.println(value)); &#125; //set相关操作 opsForSet @Test public void testSet()&#123; stringRedisTemplate.opsForSet().add(&quot;sets&quot;,&quot;xiaosan&quot;,&quot;xiaosi&quot;,&quot;xiaowu&quot;); Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(&quot;sets&quot;); sets.forEach(value-&gt; System.out.println(value)); &#125; //list相关的操作opsForList @Test public void testList()&#123; // stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;); List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(&quot;lists&quot;, 0, -1); lists.forEach(key -&gt; System.out.println(key)); &#125; //String相关的操作 opsForValue @Test public void testString()&#123; //stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;); String s = stringRedisTemplate.opsForValue().get(&quot;166&quot;); System.out.println(s); Long size = stringRedisTemplate.opsForValue().size(&quot;166&quot;); System.out.println(size); &#125; //key相关的操作 @Test public void test()&#123; Set&lt;String&gt; keys = stringRedisTemplate.keys(&quot;*&quot;);//查看所有key Boolean name = stringRedisTemplate.hasKey(&quot;name&quot;);//判断某个key是否存在 stringRedisTemplate.delete(&quot;age&quot;);//根据指定key删除 stringRedisTemplate.rename(&quot;&quot;,&quot;&quot;);//修改key的名称 stringRedisTemplate.expire(&quot;key&quot;,10, TimeUnit.HOURS); //设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位 stringRedisTemplate.move(&quot;&quot;,1);//移动key &#125;","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://xuexuexuexiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"内存数据库redis为什么这么快","slug":"redis为什么这么快","date":"2021-07-29T07:35:20.000Z","updated":"2021-07-29T07:45:29.982Z","comments":true,"path":"uncategorized/redis为什么这么快/","link":"","permalink":"https://xuexuexuexiao.github.io/uncategorized/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/","excerpt":"众所周知，Redis在内存库数据库领域非常地火热，它极高的性能和丰富的数据结构为我们的开发提供了极大的便利。 但我们也听说了，Redis是单线程的，为什么采用单线程的Redis也会如此之快呢？这篇文章我们来分析一下其中的缘由。","text":"众所周知，Redis在内存库数据库领域非常地火热，它极高的性能和丰富的数据结构为我们的开发提供了极大的便利。 但我们也听说了，Redis是单线程的，为什么采用单线程的Redis也会如此之快呢？这篇文章我们来分析一下其中的缘由。 其实，严格来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的。这一点我们一定要清楚了解到，不要单纯地认为Redis Server是单线程的！ 我们平时说的Redis单线程快是指它的请求处理过程非常地快！ 下面我们就来分下一下为什么请求处理使用单线程，依旧可以达到这么高的性能。 Redis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面： 纯内存操作 多路复用机制 单线程 非CUP密集型任务 纯内存操作Redis 是一个纯内存数据库，它的数据都存储在内存中，这意味着数据的操作都在内存中完成，这种操作是非常快的。 同时由于Redis中有一个数据类型是Hash的，它的时间复杂度是O(1)，这意味着查找速度也非常快，另外Redis还有其他的数据类型，并使用高效的操作方式操作，并不会很耗内存 多路复用机制Redis是单线程，但是怎么处理多个客户端请求呢？ 这是利用了多路复用IO和非阻塞IO的机制，这个技术由操作系统实现提供，Redis可以方便地操作系统的API即可。Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读/可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。 整个过程十分高效，Redis采用多路复用技术的事件驱动模型，保证在监听多个Socket请求的情况下，只对有活动的请求采取反应 单线程 没有上下文切换 没有访问共享变量加锁的性能损耗 开发和调试比较友好 非CPU密集型任务采用单线程的缺点很明显，无法使用多核CPU。Redis作者提到，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。 在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网络延迟等待的情况。 当然，如果你觉得单个Redis实例的性能不足以支撑业务，Redis作者推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力，而不是在单个实例上使用多线程来处理。 缺点上面介绍了单线程可以达到如此高的性能，并不是说它就没有缺点了。 单线程处理最大的缺点就是，如果前一个请求发生耗时比较久的操作，那么整个Redis就会阻塞住，其他请求也无法进来，直到这个耗时久的操作处理完成并返回，其他请求才能被处理到。 我们平时遇到Redis变慢或长时间阻塞的问题，90%也都是因为Redis处理请求是单线程这个原因导致的。 所以，我们在使用Redis时，一定要避免非常耗时的操作，例如使用时间复杂度过高的方式获取数据、一次性获取过多的数据、大量key集中过期导致Redis淘汰key压力变大等等，这些场景都会阻塞住整个处理线程，直到它们处理完成，势必会影响业务的访问。 我会在后期的文章中专门介绍具体有哪些场景会引发Redis阻塞的问题，并提供规避问题的方法和优化方案 多线程的优化在文章开头已经特别说明，Redis Server本身是多线程的，除了请求处理流程是单线程处理之外，Redis内部还有其他工作线程在后台执行，它负责异步执行某些比较耗时的任务，例如AOF每秒刷盘、AOF文件重写都是在另一个线程中完成的。 而在Redis 4.0之后，Redis引入了lazyfree的机制，提供了unlink、flushall aysc、flushdb async等命令和lazyfree-lazy-eviction、lazyfree-lazy-expire等机制来异步释放内存，它主要是为了解决在释放大内存数据导致整个redis阻塞的性能问题。 在删除大key时，释放内存往往都比较耗时，所以Redis提供异步释放内存的方式，让这些耗时的操作放到另一个线程中异步去处理，从而不影响主线程的执行，提高性能。 到了Redis 6.0，Redis又引入了多线程来完成请求数据的协议解析，进一步提升性能。它主要是解决高并发场景下，单线程解析请求数据协议带来的压力。请求数据的协议解析由多线程完成之后，后面的请求处理阶段依旧还是单线程排队处理。 可见，Redis并不是保守地认为单线程有多好，也不是为了使用多线程而引入多线程。Redis作者很清楚单线程和多线程的使用场景，针对性地优化，这是非常值得我们学习的。 总结Redis使用单线程，配合IO多路复用技术，可以完成多个连接的请求处理。而且正是由于它的使用定位是内存数据库，这样几乎所有的操作都在内存中完成，它的性能可以达到非常之高。 同时，单线程没有了线程上下文切换和访问共享资源加锁的性能损耗，而且单线程模型对程序的开发和调试非常友好，因此Redis使用单线程模型也就在情理之中了。 Redis在最近的版本也对多线程进行了优化，用于解决释放大内存数据和请求数据协议解析对Redis产生的性能影响，进一步提升了Redis的性能。 单线程结合上述场景可以达到非常高的性能，同时也存在耗时操作阻塞整个线程的问题，我们在使用Redis时要避免耗时过长的操作，才能更好地发挥Redis的性能。 参考：链接 同样可以参考","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://xuexuexuexiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}],"categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://xuexuexuexiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}